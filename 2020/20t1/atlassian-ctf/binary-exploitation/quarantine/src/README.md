# quarantine

This is the second in a series of intermediate - hard binary exploitation challenges.
______

**Category:** Binary exploitation

**Difficulty:** Intermediate - Hard

**Author:** bluecicada 

## Flavourtext (given to players)
but I want to go out

## Files

Provide these files to players:
* `quarantine` (challenge binary)

For internal use only:
* `quarantine.c` (challenge source)
* `libc6-i386_2.27-3ubuntu1_amd64.so` (libc file)
* `asdf.py` (solver script)
* `flag`
* `Makefile`
* Infra:
    * `Dockerfile`
    * `docker-compose.yml`

## Solution

Although superficially similar to `isolation`, the means of exploitation is different. 
New protections have been enabled (PIE and stack canaries), and RELRO is not enabled.

Oh, and there's an annoying `alarm()` that goes off after 12 seconds, ending your free trial.

Most of the menu options only serve to obfuscate, and are not useful for our exploit.
However, by static analysis, it should be easy enough to locate the vulnerable `printf()` call when adding rooms.

If you try to add a room with the same name twice, the room name is passed as the only argument to `printf()`, allowing for a format string exploit.
Also, since RELRO is not enabled, we can try to overwrite entries in the GOT table.

Solution steps:

    0. 
This step is optional, but you may want to patch out the `alarm()` to make dynamic analysis easier.
The easiest way to do this is to set the seconds on the `alarm()` to some massive number, but you can also patch out the `alarm()` and `signal()` entirely.

    1.
Determine the format string offset (i.e. where on the stack is our format string stored?).
We can enumerate words on the stack by abusing the vulnerable `printf()` call (though it's probably faster to just inspect the stack in gdb).

You should find that the format string is at offset 34 (you can verify this by printing `%34$x`)

    2.
We need to defeat PIE by leaking a pointer that is a constant offset away from the binary's base address.
Further inspection of the stack reveals one such pointer at offset 40, which is equal to `[base address] + 0x107c`.

Now we know the base address, we can use it to calculate the location of the GOT table.

    3.
We can use printf@got to leak libc addresses from the GOT table.
Our payload will look like 
```
[addr of printf@got (where the libc addr is located, not the libc addr itself)] 
+ %34$s
```

Using the leaked libc addresses, we can work out the libc version and the libc address of system (by this point though you should realise I've been using the same libc for all my binaries bc ceebs lel).

    4.
As it happens, the code path in the `menu_loop()` leading to the vulnerable `printf()` doesn't use `printf()` anywhere else.

And since the GOT is also writable (RELRO not enabled), the easiest attack from here would be to overwrite the GOT entry for `printf()` to point to `system()` instead, and then call `system()` with `/bin/sh` as the argument to yield us a shell.

See the solver script for an example.

## Notes

Run with `docker-compose up`.

The `docker-compose.yml` runs the chall over port 7889, but you can change this in the file (under `ports:`).
Rebuild with `docker-compose build` when you're done, and add the host and port numbers to the flavourtext and solver script.

Although second in this series of challenges, it is not necessarily harder than `isolation`.
